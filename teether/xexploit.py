import itertools
import logging
from collections import defaultdict, namedtuple
import re
import numbers

from z3 import z3


from teether.project import Project
from teether.cfg import opcodes
from teether.constraints import check_model_and_resolve, model_to_calls
from teether.evm.exceptions import IntractablePath
from teether.evm.results import CombinedSymbolicResult
from teether.util.z3_extra_util import concrete, get_vars_non_recursive, to_bytes, simplify_non_const_hashes
import teether.ponziSchemes as ponziSchemes

import time
import timeout_decorator
import sha3

CALLER = 0
SYMVAR = 1
DSA    = 2
MAP    = 3

HASHMAP = dict()

FALLBACK = 'fallback'

class InfeasibleExploit(Exception):
    pass


class FCSigError(Exception):
    pass


class ExploitContext(object):
    def __init__(self, target_addr, shellcode_addr, target_amount, amount_check, initial_balance, initial_storage,
                 controlled_addrs=set()):
        self.target_addr = target_addr
        self.shellcode_addr = shellcode_addr
        self.target_amount = target_amount
        self.amount_check = amount_check
        self.initial_balance = initial_balance
        self.initial_storage = initial_storage

        # assume we control the target address
        self.controlled_addrs = controlled_addrs | {target_addr}


    

def exploit_constraints_call(r, ctx):
    addr = r.state.stack[-2]
    if not concrete(addr):
        addr = z3.simplify(addr)

    amount = r.state.stack[-3]
    if not concrete(amount):
        amount = z3.simplify(amount)

    extra_constraints = []

    if not concrete(addr):
        extra_constraints.append(z3.Extract(159, 0, addr) == ctx.target_addr)
    else:
        if addr != ctx.target_addr:
            raise InfeasibleExploit

    if not concrete(amount):
        if ctx.amount_check == '+':
            extra_constraints.append(z3.UGE(amount, ctx.target_amount))
        elif ctx.amount_check == '-':
            extra_constraints.append(z3.UGT(amount, 0))
            extra_constraints.append(z3.ULE(amount, ctx.target_amount))
        else:
            extra_constraints.append(amount == ctx.target_amount)
        final_balance = r.state.balance
        extra_constraints.append(z3.ULE(amount, final_balance))

    # ensure we're not spending more for this exploit than we gain
    total_spent = None
    for res in r.results:
        callvalue = z3.BitVec('CALLVALUE_%d' % res.xid, 256)
        extra_constraints.append(z3.ULE(callvalue, 10 * (10 ** 18)))  # keep it semi-reasonable: at most 10 Eth per call
        if total_spent is None:
            total_spent = callvalue
        else:
            total_spent += callvalue

    extra_constraints.append(z3.ULT(total_spent, amount))

    # also, ensure the contract does not require a unreasonable start-balance (>100 Eth)
    if not ctx.initial_balance:
        start_balance = z3.BitVec('BALANCE_%d' % r.results[0].xid, 256)
        extra_constraints.append(z3.ULE(start_balance, 100 * (10 ** 18)))

    return extra_constraints


def exploit_constraints_callcode(r, ctx):
    addr = z3.simplify(r.state.stack[-2])

    extra_constraints = []

    if not concrete(addr):
        extra_constraints.append(z3.Extract(159, 0, addr) == ctx.shellcode_addr)
    else:
        if addr != ctx.shellcode_addr:
            raise InfeasibleExploit

    return extra_constraints


def exploit_constraints_delegatecall(r, ctx):
    addr = z3.simplify(r.state.stack[-2])

    extra_constraints = []

    if not concrete(addr):
        extra_constraints.append(z3.Extract(159, 0, addr) == ctx.shellcode_addr)
    else:
        if addr != ctx.shellcode_addr:
            raise InfeasibleExploit

    return extra_constraints


def exploit_constraints_selfdestruct(r, ctx):
    addr = z3.simplify(r.state.stack[-1])

    extra_constraints = []

    if not concrete(addr):
        extra_constraints.append(z3.Extract(159, 0, addr) == ctx.target_addr)
    else:
        if addr != ctx.target_addr:
            raise InfeasibleExploit

    return extra_constraints

def exploit_constraints_invest(r, ctx, payable=False):
    tmp = r.state.stack[-1]
    logging.info(f'# payable = {payable}#Try to solve: storage@')
    # slot = r.state.stack[-1] if concrete(tmp) else z3.simplify(tmp)
    addr = r.state.stack[-2]

    extra_constraints = []
    if not concrete(addr):
        extra_constraints.append(z3.simplify(z3.Extract(159, 0, addr)) == ctx.target_addr)
    else:
        if addr != ctx.target_addr:
            raise InfeasibleExploit

    for res in r.results:
        callvalue = z3.BitVec('CALLVALUE_%d' % res.xid, 256)
        if payable:
            extra_constraints.append(z3.UGT(callvalue, 0)) 
        else:
            extra_constraints.append(callvalue == 0) 


    # also, ensure the contract does not require a unreasonable start-balance (>100 Eth)
    # if not ctx.initial_balance:
    #     start_balance = z3.BitVec('BALANCE_%d' % r.results[0].xid, 256)
    #     extra_constraints.append(z3.ULE(start_balance, 100 * (10 ** 18)))

    return extra_constraints

EXPLOIT_CONSTRAINTS = {
    # 'CALL': exploit_constraints_call,
    # 'CALLCODE': exploit_constraints_callcode,
    # 'DELEGATECALL': exploit_constraints_callcode,
    'SSTORE': exploit_constraints_invest
}


def get_exploit_constraints(r, ctx):
    target_op = r.results[-1].target_op
    if target_op in EXPLOIT_CONSTRAINTS:
        return EXPLOIT_CONSTRAINTS[target_op](r, ctx)
    else:
        return []

def control_address_constraints(sym_addr, controlled_addrs):
    sub_exprs = [sym_addr == controlled_addr for controlled_addr in controlled_addrs]
    expr = sub_exprs[0]
    for sub_expr in sub_exprs[1:]:
        expr = z3.Or(expr, sub_expr)
    return expr

def attempt_exploit(results, ctx):
    c = CombinedSymbolicResult()
    for r in results[::-1]:
        c.prepend(r)
    c.combine(ctx.initial_storage, ctx.initial_balance)
    c.simplify()
    extra_constraints = get_exploit_constraints(c, ctx)

    for res in c.results:
        origin = z3.BitVec('ORIGIN_%d' % res.xid, 256)
        caller = z3.BitVec('CALLER_%d' % res.xid, 256)
        # ensure we control the origin
        extra_constraints.append(control_address_constraints(origin, ctx.controlled_addrs))
        # and ensure the caller is either the origin or the shellcode address
        extra_constraints.append(control_address_constraints(caller, {origin, ctx.shellcode_addr}))

    try:
        model = check_model_and_resolve(c.constraints + extra_constraints, c.sha_constraints)

        # enforce we control all ORIGIN-addresses
        if any(model[v].as_long() not in ctx.controlled_addrs for v in model if v.name().startswith('ORIGIN')):
            raise InfeasibleExploit

        return True# model_to_calls(model, c.idx_dict), c, model
    except IntractablePath:
        raise InfeasibleExploit

def attempt_exploit1(results, ctx, payable=False):
    c = CombinedSymbolicResult()
    for r in results[::-1]:
        c.prepend(r)
    c.combine(ctx.initial_storage, ctx.initial_balance)
    c.simplify()
    extra_constraints = exploit_constraints_invest(c, ctx, payable=payable)

    for res in c.results:
        origin = z3.BitVec('ORIGIN_%d' % res.xid, 256)
        # caller = z3.BitVec('CALLER_%d' % res.xid, 256)
        # ensure we control the origin
        extra_constraints.append(control_address_constraints(origin, ctx.controlled_addrs))
    try:
        model = check_model_and_resolve(c.constraints + extra_constraints, c.sha_constraints)
        # enforce we control all ORIGIN-addresses
        if any(model[v].as_long() not in ctx.controlled_addrs for v in model if v.name().startswith('ORIGIN')):
            raise InfeasibleExploit
        return True #model_to_calls(model, c.idx_dict), c, model
    except IntractablePath:
        raise InfeasibleExploit


def simplify_str(value):
    #print ("type: " + str(type(value)))
    if type(value) == int:
        return str(value)
    elif type(value) == str:
        return str(value).replace('\n', ' ')
    elif type(value) == bool:
        return str(value)
    elif type(value) == list:
        return ",".join(simplify_str(f) for f in value)
    else:
        return " ".join(str(simplify(value)).split())

def feat_body(expr):
    if expr.num_args() == 0: # a symbolic
        return None
    elif expr.decl().name() == 'bvand':
        children = expr.children()
        body = children[1] if simplify_str(children[0]).strip() == str(((2 << 160 - 1) - 1)).strip('L')  else children[0]
        return body
    else:
        return None

def is_read_from(one, usrDB):
    for item in usrDB:
        ins_addr, index, _,_  = item
        if one == index:
            return item
    return None
    
    if not self.symbolic_reads and not other.symbolic_writes:
        # no side has a non-hash-based symbolic access
        # => only concrete accesses can intersect
        # (or hash-based accesses, which we will check later)
        if self.concrete_reads & other.concrete_writes:
            return True
    else:
        # at least one side has a non-hash-based symbolic access
        # => if there is at least one concrete or symbolic access
        # on the other side, the two could be equal
        # (otherwise we have to look at hash-based accesses, see below)
        if ((self.symbolic_reads or self.concrete_reads or self.symbolic_hash_reads) and
                (other.symbolic_writes or other.concrete_writes or other.symbolic_hash_writes)):
            return True

    if self.symbolic_hash_reads and other.symbolic_hash_writes:
        for a, b in itertools.product(self.symbolic_hash_reads, other.symbolic_hash_writes):
            if not ast_eq(a, b):
                continue
            hash_a = list(self._vars[a] & set(self.result.sha_constraints.keys()))
            hash_b = list(other._vars[b] & set(other.result.sha_constraints.keys()))
            if len(hash_a) != 1 or len(hash_b) != 1:
                # multiple hashes on either side
                # => assume they could be equal
                return True
            # only one hash on either side
            # => check whether these two can actually be equal
            d_a = self.result.sha_constraints[hash_a[0]]
            d_b = other.result.sha_constraints[hash_b[0]]
            if isinstance(d_a, SymRead) or isinstance(d_b, SymRead):
                return True
            if d_a.size() == d_b.size():
                return True

    # at this point, we have checked every possible combination
    # => no luck this time
    return False



def feat_key_base(laser, expr):
   #( storage_0 + keccak256[65535 & UDiv(storage_0, 65536), 1])
    str_key_adr = str(expr)[8:]
    sym_key_adr = laser.varlist[str_key_adr]
    adc = sym_key_adr.children()
    if adc:
        sym_keccakp, struct_idx  = adc if 'keccak256[' in str(adc[0]) else adc[::-1]
        key, base = laser.keccaks[str(sym_keccakp)]
    else:
        key, base = laser.keccaks[str(sym_key_adr)]
    return key, base

def is_caller(expr, xid):

    # print("[-] iscaller(): ", expr)
    res, _ = get_concrete(expr)
    if res:
        return False
    
    # fast mode
    if re.search("^Extract\(159, 0, CALLER_\d+\)$", str(expr)) or \
        re.search("^Extract\(255, 96, 79228162514264337593543950336\*CALLER_\d+\)$", str(expr)) or \
        re.search("^Extract\(255, 96, CALLER_\d+\*79228162514264337593543950336\)$", str(expr)) :
        return True
    
    for offset in range(0, expr.size()-160+8, 8):
        # print(offset, expr, expr.size())
        part = z3.simplify(z3.Extract(159+offset, 0+offset, expr))
        tmp = z3.z3util.get_vars(part)
        if len(tmp) != 1 or (len(tmp) ==1 and str(tmp[0]).strip() != 'CALLER_%d' % (xid)):
            continue

        constraint = part == z3.Extract(159, 0, z3.BitVec('CALLER_%d' % (xid), 256))
        s = z3.Solver()
        s.add(constraint)
        if s.check() == z3.sat:
            return True
    return False


def is_origin(expr):
    # print(expr)
    if re.search("^Extract\(159, 0, ORIGIN_\d+\)$", str(expr)) or \
        re.search("^Extract\(255, 96, 79228162514264337593543950336\*ORIGIN_\d+\)$", str(expr)) or \
        re.search("^Extract\(255, 96, ORIGIN_\d+\*79228162514264337593543950336\)$", str(expr)) :
        return True
    return False


def get_concrete(address):
    if isinstance(address, z3.BitVecNumRef):
        return True, address.as_long()
    elif isinstance(address, numbers.Number):
        return True, int(address)
    else:
        return False, address

def get_storage_expr_base(sha_constraints, expr):
    try:
        res, expr = get_concrete(expr)
        if res:
            return -1, -1, -1
            
        # print('input to func:',expr, type(expr))
        if expr.decl().name() == 'extract':
            # print('extract.children=',expr.children(), expr)
            p_h, p_l = expr.decl().params()
            expr = expr.children()[0]
            # print('len=', p_h - p_l)
            if p_h - p_l == 159:
                # type: address
                if p_h == 159:
                    pass
                    # print("length == 159")
                else:
                    pass
                    # tmp = expr.children()
                    # print("TMP not begin low:", tmp, '===', expr)

            else:
                expr = expr.children()[0]
                if expr.decl().name() == 'bvmul':
                    tmp = expr.children()
                    expr = tmp[0] if tmp[0].decl().name() == 'select' else tmp[1]
        # print('before select ',expr)
        if expr.decl().name() != 'select':
            return expr, None, None
        # select()
        address = expr.children()[1]

        if address.decl().name() == 'bvadd' and str(address.children()[1]).startswith('SHA3_'):
            address = address.children()[1]
        # print('func: ',address, type(address))
        res, address = get_concrete(address)
        # print('after concrete ', res, address, address in sha_constraints)
        if res:
            # print("is concrete:", address)
            if address <= 1024:
                return SYMVAR, address, None
            else:
                slot = hash2idx(hex(address)[2:])
                if slot == -1:
                    return MAP, address, 0
                else:
                    return DSA, slot, 0
        elif address in sha_constraints:
            #sha3
            identity = sha_constraints[address]
            # print('id:', repr(identity))
            # print('children=', identity.children())
            # print('----', address)
            #Concat(0, Extract(7, 0, STORAGE_2[SHA3_24_2]), 5)
            if identity.decl().name() == 'concat':
                # print('len=', len(identity.children()))
                # print(identity.children())
                # key, base = identity.children()
                base = identity.children()[-1]
                # print('key=', key)
                # exit(0)
                key = identity.children()[0]
                # print(identity.children())
                for item in identity.children()[1:-1]:
                    key = z3.Concat(key, item)
                # print('key ===', key)
                return MAP, base, key
        else:
            var_adds = address.children()
            i = 0
            while i < len(var_adds):
                one_var = var_adds[i]
                if one_var.decl().name() == 'bvadd':
                    var_adds = var_adds[:i] + one_var.children() + var_adds[i+1:]
                else:
                    i += 1
            first_var = var_adds[0]
            _, base = get_concrete(first_var)
            key = 0
            for item in var_adds[1:]:
                key = key+item
            return DSA, hash2idx(hex(int(base))[2:]), key
    except Exception as e:
        print("[-] ERROR========", e)
        return None, None, None

     
def hash2idx(_hash):
    for key in HASHMAP.keys():
        if 0 <= int(key, 16) - int(_hash, 16) <= 4096:
            # print("Found --->", HASHMAP[key])
            return HASHMAP[key]
    return -1

def get_sidx(sha_constraints, adr):
    # 62514009886607029107290561805838585334079798074568712924583230797734656856475 + STORAGE_1[4] + 1 - 1
    try:        
        # tmp = re.search(r"([0-9]{70,80})", str(adr))
        # if isinstance(adr, z3.BitVecNumRef):
        #     adr = adr.as_long()
        # elif concrete(adr):
        #     adr = int(adr)

        # if tmp:
        #     return hash2idx(hex(int(tmp.group().strip()))[2:]) 
        # return adr

        # if len(adr.children()) == 0:

        # SYMVAR
        tmp = re.search(r"([0-9]{70,80})", str(adr))
        if isinstance(adr, z3.BitVecNumRef):
            if tmp:
                return hash2idx(hex(int(tmp.group().strip()))[2:]) 
            return adr.as_long()
        elif concrete(adr):
            if tmp:
                slot = hash2idx(hex(adr)[2:])
                if slot == -1:
                    return adr
                else:
                    return slot

                return hash2idx(hex(int(tmp.group().strip()))[2:]) 
            return adr
        # print(r.sha_constraints)
        # print(r.sha_constraints[z3.z3util.get_vars(adr)[0]])
        adr_str = str(adr).replace('\n', ' ').strip()
        # print("address = ", adr, adr_str.count("SHA3_"))
        # mapping
        if adr_str.count("SHA3_") == 1:
            # Concat(0, Extract(159, 0, CALLER_1), 0)
            base = sha_constraints[z3.z3util.get_vars(adr)[0]] 
            # print("base == ", base)
            if base.decl().kind() == 1056:# Concat
                # print(base.children())
                key = int(str(base.children()[-1]))
                # print('key=', key)
                return key
        # DSA
        else:
            # print('[-] feat_base::', adr)
            base_adr = re.search(r"([0-9]{70,80})", adr_str).group().strip()
            # print('inline---', base_adr)
            return hash2idx(hex(int(base_adr))[2:]) 
    except:
        return -1

def prase_bonus(sha_constraints, expr):
    try:
        # print('bonus### ',z3.z3util.get_vars(expr))
        for child in expr.children():
            if child.decl().name() == 'select':
                kind, base, _ = get_storage_expr_base(sha_constraints, children)
            else:
                pass
            
            s = z3.Solver()
            s.add(expr == 1e20)
            if s.check == z3.sat:
                return s.model().eval(var).as_long() / 1e20

    except:
        pass
    return None


def prase_ast(expr):
    children = list()
    if expr.children() == []:
        return expr
    for child in expr.children():
        if child.decl().name() == 'select':
            children.append(z3.BitVecVal(1e20, child.size()))
        else:
            children.append(child)

    op = expr.decl().name()
    print('[+] expr=', expr, '\n[+]childrens = ', children)
    if op == 'bvadd':
        return prase_ast(children[0]) + prase_ast(children[1])

    if op == 'bvsub':
        return prase_ast(children[0]) - prase_ast(children[1])

    if op == 'bvmul':
        return prase_ast(children[0]) * prase_ast(children[1])
    
    elif op == 'bvudiv':
        return z3.UDiv(prase_ast(children[0]), prase_ast(children[1])) 
    
    elif op == 'bvsdiv':
        return prase_ast(children[0]) / prase_ast(children[1])

    elif op == 'bvand':
        return prase_ast(children[0]) & prase_ast(children[1])

    elif op == 'bvor':
        return prase_ast(children[0]) | prase_ast(children[1])



# def get_func_sig(p, path):
#     '''
#     DUP1      
#     PUSH4     0x27e235e3# func_sig
#     EQ        
#     PUSH2     addr
#     JUMPI    
#     '''
#     if p.func_entries[FALLBACK] in path:
#         return FALLBACK
#     for sig, entry in p.func_entries.items():
#         if entry in path:
#             return sig
#     return FALLBACK

#     func_sig, jump_addr = None, None
#     dispatcher_pattern = ['DUP1', 'PUSH4', 'EQ', 'PUSH2', 'JUMPI']
#     pattern_size = len(dispatcher_pattern)
#     # print("Path: %s", '->'.join('%x' % p for p in path))
#     for i, node in enumerate(path[:-1]):
#         bb = p.cfg._bb_at[node]
#         next_node = path[i+1]
#         if len(bb.ins) < pattern_size:
#             continue
#         todo_match = [(_i.name, _i.arg) for _i in bb.ins][-1*pattern_size:]
#         idx = 0
#         while idx < pattern_size:
#             name, arg = todo_match[idx] 
#             if name != dispatcher_pattern[idx]:
#                 break
#             if name == 'PUSH4':
#                 func_sig = arg.hex()
#             if name == 'PUSH2':
#                 jump_addr = arg.hex()
#             idx += 1
#         if idx == pattern_size and int(jump_addr, 16) == next_node:
#             return func_sig

#     return FALLBACK


def convert_concrete(v):
    if isinstance(v, numbers.Number):
        return v

    elif isinstance(v, z3.BitVecNumRef):
        return v.as_long()
    return v


def constraint_require_pay(i_r, func_sig):
    if func_sig == FALLBACK:
        return True

    if not any(["CALLVALUE" in str(item) for item in i_r.constraints]):
        return False

    # if one contraint require callvalue > 0
    # => find a path to invest (sstore msg.sender)
    # e.g.  If(UGT(CALLVALUE_9, 1000000000000000000), 1, 0) == 1
    for _cons in i_r.constraints:
        print(_cons)
        # quick mode
        try:
            svars = z3.z3util.get_vars(_cons)
            if not(len(svars) == 1 and str(svars[0]).startswith("CALLVALUE_")):
                continue
            var_callvalue = svars[0]
            s = z3.SolverFor("QF_ABV")
            s.add(_cons)
            s.push()
            s.add(var_callvalue == 0)
            if s.check() == z3.unsat:
                # print("fitst solver === ", s)
                s.pop()
                s.add(z3.UGT(var_callvalue, 0))
                # print("second solver ===", s)
                if s.check() == z3.sat:
                    return True
        except:
            continue
    
    # the path is reachable ,iff the callvalue is larger than zero
    # try:
    #     # the path is unreachable if callvalue equal to zero
    #     if attempt_exploit1([i_r], ctx, payable=False):
    #         return False
    #         # print("===================== payable False Solved ===================")
        
    # except InfeasibleExploit as e:
    #     # print("===================== payable False unSolved ===================")
    #     try:
    #         # the path is reachable iff callvalue larger than zero
    #         _ = attempt_exploit1([i_r], ctx, payable=True)
    #         # print("===================== payable True Solved ===================")
    #         return True
    #         # return results
    #     except InfeasibleExploit as e:
    #         # print("===================== payable True unSolved ===================")
    #         return False
    return False

def query_db(adr):
    if adr == 1353969418847661534731502722588304955362084559736:
        with open('/home/toor/SADPonzi/dataset/cross_cases/oldeth.bin') as infile:
            inbuffer = infile.read().rstrip()
        xcode = bytes.fromhex(inbuffer)
        return xcode

# @timeout_decorator.timeout(20*60, timeout_exception=StopIteration, use_signals=False)
def combined_exploit(p, target_addr, shellcode_addr, target_amount, amount_check='+', initial_storage=dict(),
                     initial_balance=None,
                     max_calls=3, controlled_addrs=set(), flags=None, looplimit=3):

    global HASHMAP
    sn = [sha3.keccak_256(item.to_bytes(length=32, byteorder='big')).hexdigest() for item in range(64)]
    for i, s in enumerate(sn):
        # print(i, ' ', int(s, 16))
        HASHMAP[s] = i

    results = list()
    # flags = flags or set(opcodes.CRITICAL)
    ctx = ExploitContext(target_addr, shellcode_addr, target_amount, amount_check, initial_balance, initial_storage,
                         controlled_addrs)
    # ========================================================================
    # sload_bbs = {ins.bb.start for ins in p.cfg.filter_ins('SLOAD')} # static

    # locate invest
    # => get all possible invest action
    # p.get_func_entry()
    ins = p.cfg.filter_ins('SSTORE') 
    if not ins:
        logging.info('No %s instructions', 'SSTORE')
        return False
    sstore_inses = list()
    tmp=0
    
    priority_sstores = list()
    for i in ins:
        if p.func_entries[FALLBACK] in i.bb.ancestors:
            # sstore_inses.insert(0, i)
            intrest_flag = False
            
            for _i in i.bb.ins:
                if _i.addr < i.addr:
                    # print(_i)
                    # exit(0)
                    if _i.name in ('CALLER', 'ORIGIN'):
                        intrest_flag = True
                        # print("FOUNDDDD=========================================")
                        break
            if intrest_flag:
                priority_sstores.insert(0, i)
            else:
                priority_sstores.append(i)
            tmp += 1
        else:
            sstore_inses.append(i)

    sstore_inses = priority_sstores + sstore_inses

    balance_slots =  list()
    print(tmp, len(sstore_inses))
    # exit()
    # logging.info('Found %d %s instructions', len(ins), op)
    invest_usr_act = list()
    # critial_sstores = list()
    time_start = time.time()

    side_rewards = list()
    side_balances = list()
    _tmp = 0
    st_invest = time.time()
    for sstore_ins in sstore_inses:
        _tmp += 1
        # for  ../dataset/rq1/ponzi//b336a86e2feb1e87a328fcb7dd4d04de3df254d0 &  83651a62b632c261442f396ad7202fe2a4995e3a set limit == 1
        if  len(invest_usr_act) > 1 or time.time() - st_invest > 3*60: # limit 
            break

        # for 1bb6123913d0b48948de38c3b75fd3eb3b4fe7e3, pls set 80 looplimits here
        for i, i_path, i_r in p.get_constraints([sstore_ins], looplimit=3): # generate constrain for a path to critical Opcodes------symbolic
            if (not i) or (not i_path) or (not i_r):
                break
            print(f"[dubug] collect invest {len(invest_usr_act)} act")

            # for _hs in i_r.history_states:
            #     if _hs.name == 'CALL':
            #         side_rewards.append((_hs, [], i_r))
            # print(len(invest_usr_act))
            # if len(invest_usr_act) > 0:
            #     break
            # verity caller == ...


            # time_round = time.time()
            # if time_round - time_start > 60*3 
            # current path is invalid
            # print('==================== a new round ==============')

            # logging.info("%s: %s", op, i)
            logging.info("Path: %s", '->'.join('%x' % _p for _p in i_path))
            # print(i, i_path)
            # print('----------------')
            # for _PPP in p.cfg._bb_at[i_path[-2]].ins:
            #     print(_PPP)
            slot = i_r.state.stack[-1]
            _sval = i_r.state.stack[-2]
            
            res, _sval = get_concrete(_sval)
            
            sval = _sval if res else z3.simplify(_sval) 
            # print(f'slot={get_sidx(i_r.sha_constraints, slot)} --> {slot};val:{sval}')
            func_sig = p.get_func_sig(i_path[:-1])

            if 'CALLVALUE' in str(sval): 
                # current_bb_id = i.bb.start
                # bb_descendants = p.cfg._bb_at[current_bb_id].descendants
                # bb_ancestors   = p.cfg._bb_at[current_bb_id].ancestors
                # if len(bb_descendants & bb_ancestors) > 0 or \
                #     i_path.count(current_bb_id) > 1:
                # balanceOf[address]
                try:
                    key = i_r.sha_constraints[slot].children()[-2]
                    if key.size() == 160:
                        if key.children()[0].decl().name() == 'select': 
                            key = key.children()[0]
                            if "CALLER" not in str(key.children()[1] ) and "ORIGIN" not in str(key.children()[1]):
                                balance_slots.append(get_sidx(i_r.sha_constraints, slot))
                except:
                    pass
                
                # critial_sstores.append((i, func_sig, i_r))
            # if "CALLER" in str(sval):
            # print(f'function:{func_sig}\nslot={get_sidx(i_r.sha_constraints, slot)} --> {slot};val:{sval}')
            
            # ponzitract recored the receipent with the msg.sender
            # print(slot, sval)
            # Extract(255, 96, 79228162514264337593543950336*CALLER_3)
            

            if not (is_caller(sval, i_r.xid) or is_origin(sval)):
                break
            # print("YEAH CALLER")
            # print(f'function:{func_sig}\nslot={get_sidx(i_r, slot)} --> {slot};val:{sval}')
            # if in fallback()
            # must be a invest action
            if func_sig == FALLBACK:
                invest_usr_act.append((i_r.sha_constraints, func_sig,  slot))
                # print("---leave")
                break
            # invest_usr_act.append((i_r.sha_constraints, func_sig,  slot))
            # continue
       
            
            if not any(["CALLVALUE" in str(item) for item in i_r.constraints]):
                break
            
            # filter change_owner()
            # e.g. If( Storage[0] == caller, 0, 1)
            if len(i_r.constraints) < 10000:
                flag_in_change_owner = False
                try:
                    for _cons in i_r.constraints:
                        if _cons.decl().name() != 'if':
                            continue
                        expr = _cons.children()[0]
                        if expr.decl().name() != '=' or len(expr.children()) != 2:
                            continue
                        ts = z3.z3util.get_vars(expr.children()[0]) + z3.z3util.get_vars(expr.children()[1])
                        if 'STORAGE' in str(ts[0]):
                            owner = ts[0]
                            caller = ts[1]
                        else:
                            owner = ts[1]
                            caller = ts[0]
                        if convert_concrete(owner.children()[1]) == convert_concrete(slot):
                            flag_in_change_owner = True
                            break
                    if flag_in_change_owner:
                        break
                except:
                    pass
            print(sval, '==============================')
            # print(f'##invest {str(slot)[:20]}@', '#', str(sval)[:40])
            # print(i_r.constraints)

            # if one contraint require callvalue > 0
            # => find a path to invest (sstore msg.sender)
            # e.g.  If(UGT(CALLVALUE_9, 1000000000000000000), 1, 0) == 1
            # invest_usr_act.append((i_path, func_sig, i_r))
            # continue
            r1_flag = False
            # try:
            # continue
            for _cons in i_r.constraints:
                # print(_cons)
                # quick mode
                svars = z3.z3util.get_vars(_cons)
                # print("svar=", svars)
                # if not(len(svars) == 1 and str(svars[0]).startswith("CALLVALUE_")):
                #     print('continue:', svars)
                #     continue
                var_callvalue = svars[0]
                # print("[+] callvalue_sym=", var_callvalue)
                # print("current cons:", _cons)
                s = z3.SolverFor("QF_ABV")
                s.add(_cons)
                s.push()
                s.add(var_callvalue == 0)
                # print("out:", s.check())
                if s.check() == z3.unsat:
                    # print("fitst solver === ", s)
                    s.pop()
                    s.add(z3.UGT(var_callvalue, 0))
                    # print("second solver ===", s)
                    if s.check() == z3.sat:
                        # invest_usr_act.append((i_path, func_sig, i_r))
                        invest_usr_act.append((i_r.sha_constraints, func_sig,  slot))
                        r1_flag = True
                        break
            # except:
                # pass
            # print('r1 flag ---------------------', r1_flag)
            if r1_flag == True:
                break
            
            '''
            # print('---------------')
            # the path is reachable ,iff the callvalue is larger than zero
            try:
                # the path is unreachable if callvalue equal to zero
                if attempt_exploit1([i_r], ctx, payable=False):
                    break
                    # print("===================== payable False Solved ===================")
             
            except InfeasibleExploit as e:
                # print("===================== payable False unSolved ===================")
                try:
                    # the path is reachable iff callvalue larger than zero
                    print(i_r.constraints)
                    _ = attempt_exploit1([i_r], ctx, payable=True)
                    # print("===================== payable True Solved ===================")
                    # invest_paths.append(i_r)      
                    invest_usr_act.append((i_path, func_sig,  i_r))
                    # print(i_r.state.storage.mapping)
                    break
                    # return results
                except InfeasibleExploit as e:
                    # print("===================== payable True unSolved ===================")
                    # invalid_sstore.append(i.addr)
                    pass
            '''
            try:
                # continue
                # the path is reachable iff callvalue larger than zero
                _ = attempt_exploit1([i_r], ctx, payable=True)      
                invest_usr_act.append((i_r.sha_constraints, func_sig,  slot))
                break
            except InfeasibleExploit as e:
                print("===================== payable unSolved ===================")
                # invalid_sstore.append(i.addr)
                break
            

    # # unfortunaly for this time
    # if not invest_usr_act:
    #     print("No invest")
    #     logging.info('No Invest action')
    #     return False

    receipt_slots =  [get_sidx(sha_constraints, slot) for sha_constraints, sig, slot in invest_usr_act]

    print(receipt_slots, balance_slots)
    # print(side_rewards)
    # exit(0)
    # receipt_slots.append(5)
    if not receipt_slots and not balance_slots:
        return False
    # usrs_slots = [(get_sidx(store_r, store_r.state.stack[-1]), sig) for _, sig, store_r in invest_usr_act] + \
    #                 [(get_sidx(store_r,  store_r.state.stack[-1]), sig) for _,sig, store_r in critial_sstores]
    # tmp = []
    # for item, sig in usrs_slots:
    #     if item != -1:
    #         tmp.append(item)
    # usrs_slots =  tmp
    # print("[+] user info in ", usrs_slots)
    
    # ====================== reward action ===============================
    print('*'*40)
    calls = p.cfg.filter_ins('CALL') 

    if not calls:
        return False
    for _c in calls:
        for call_i, call_p, call_r in p.get_constraints([_c],  looplimit=looplimit, side_rewards=side_rewards): # call
            if (not call_i) or (not call_p) or (not call_r):
                break
            print('='*40)
            _gas, _receipt, _value, argO, argL, retO, retL = call_r.state.stack[-7:][::-1]
            print("r=", _receipt)
            if not (concrete(_receipt) and _receipt <= 8): 
                try:
                    # print('[+] not_receipt = ', z3.simplify( _receipt))
                    calldata = call_r.state.memory.read(argO, 32) # functing sig/calldata
                    xcode = query_db(_receipt)
                    xp = Project(xcode)
                    for x_i, x_p, x_r in xp.get_constraints(xp.cfg.filter_ins('RETURN')):
                        try:
                            xfunc_sig = ''.join([hex(d)[2:] for d in calldata[:4]])
                            print("[+] xfinc_sig=", xfunc_sig)
                        except:
                            pass
                        if xp.get_func_sig(x_p) != xfunc_sig:
                            continue
                        xretO, xretL = x_r.state.stack[-2:][::-1]
                        xretMem = x_r.state.memory.read(xretO, xretL)
                        p.xcall.append((call_i.addr, xretMem))
                        print('corss xid=', x_r.xid)
                        # print('xdadta=', xretMem)
                        break
                except:
                    pass
            # print('[+] xid=', call_r.xid)
            # print('[+] receipt = ', z3.simplify(_receipt), '\n---------------receipt -----------\n')
            
            # t = call_r.state.storage[1].children()[0]
            # print(t.children(),'--------------\n', t.children(), '--------')
            # # exit(0)
            # while t.decl().name() == 'store':
            #     t = t.children()[0]
            # print('storage[1] = ',t, '\n===')
            res, _receipt = get_concrete(_receipt)
            if res:
                # print("_receipt is concrete:", _receipt)
                break

            try:
                # print('before:', _receipt)
                _receipt = z3.simplify(z3.Extract(159, 0, _receipt))
                # print('after:', _receipt)
            except:
                continue
            
                    
            print('========== start ===========')
            if False:
                print("debug _receipt=", _receipt)
                print(_receipt.children()[0].children()[1], call_r.sha_constraints[_receipt.children()[0].children()[1]])
                print('out_func =', get_storage_expr_base(call_r.sha_constraints, _receipt))
                # exit(0)
            if is_caller(_receipt, call_r.xid):
                var_kind_receipt, base_receipt, key_receipt  = CALLER, -1, None
            else:
                var_kind_receipt, base_receipt, key_receipt = get_storage_expr_base(call_r.sha_constraints, _receipt)
            try:
                print('key=====', z3.z3util.get_vars(key_receipt)[0])
            except:
                pass
            # exit(0)
            # try:
            #     promissing = simplify(prase_ast(_value)).as_long()/1e20
            # except:
            #     promissing = -1
            
            try:
                _value = z3.simplify(_value)
                res, expr = get_concrete(_value)
                if res:
                    var_kind_value, base_value, key_value  = -1, -1, None
                else:
                    var_kind_value, base_value, key_value = get_storage_expr_base(call_r.sha_constraints, _value)
            except:
                _value = -1
                var_kind_value, base_value = -1, -1

            # handover is pyramid, because we has found the SSTORE(receipt, caller)
            flag_pyramid = False
            # receipt indicate the pyramid structure
            if any([_pt in str(key_receipt) for _pt in ['STORAGE_', 'CALLER_', 'ORIGIN_', 'CALLDATA']]):
                flag_pyramid = True

            current_bb_id = call_i.bb.start
            bb_descendants = p.cfg._bb_at[current_bb_id].descendants
            bb_ancestors   = p.cfg._bb_at[current_bb_id].ancestors
            if len(bb_descendants & bb_ancestors) > 0 or \
                call_p.count(current_bb_id) > 1:
                    print("In loop")
                    # print(bb_descendants & bb_ancestors)
                    # print(call_p.count(current_bb_id))
                    flag_pyramid = True
            # if 'SHA3_' in str(_receipt):
            #     tt = _receipt.children()[0].children()[1]
            #     print(tt)
            #     print(tt in call_r.sha_constraints)
            #     print('++', call_r.sha_constraints[tt].children()[-1], key_receipt)
            # print('### #receipt in@\n', base_receipt, _receipt)
            # try:
            #     print(f"address == {_receipt.children()[0].children()[1]}")
            # except:
            #     pass
            # print('### #value in@', base_value, _value)
            print('========== end ===========')
            # continue
            # flag_pyramid = True
            if base_receipt == -1:
                # caller
                # a new investment is divided to participated players
                # if key_value 
                if base_value in balance_slots:
                    if var_kind_value == SYMVAR:
                        possible_ans = ponziSchemes.HANDOVER
                    elif var_kind_value == DSA:
                        possible_ans = ponziSchemes.CHAINSC
                    elif var_kind_value == MAP:
                        possible_ans = ponziSchemes.TREESC
                    else:
                        possible_ans = DSA
                    # print(f"bonus#{base_value}# = ", _value)
                    # if promissing != -1:
                    # print("1 REWARD:", base_value, balance_slots)
                    # if flag_pyramid:
                    return (1, possible_ans)
            
            elif base_receipt in receipt_slots:
                if var_kind_receipt == SYMVAR:
                    possible_ans = ponziSchemes.HANDOVER
                    flag_pyramid = True
                elif var_kind_receipt == DSA :
                    possible_ans = ponziSchemes.CHAINSC
                elif var_kind_receipt == MAP:
                    possible_ans = ponziSchemes.TREESC
                else:
                    possible_ans = DSA
                # print(f"bonus#{base_value}# = ", _value)
                # print("2 REWARD:", base_receipt, receipt_slots)
                if flag_pyramid:
                    return (2, possible_ans)
            else:
                continue

                # is_exist = False
                # for ins, _, r, _ in all_reward_acts:
                #     if call_i.addr == ins.addr and call_r.state.stack[-2].get_id() == r.state.stack[-2].get_id():
                #         is_exist = True
                #         break
                # if not is_exist:
                #     all_reward_acts.append((call_i, call_p, call_r, possible_ans))
                # return possible_ans

    return False
  