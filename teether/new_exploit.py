import itertools
import logging
from collections import defaultdict, namedtuple
import re
import numbers

from z3 import z3

from teether.project import Project
from teether.cfg import opcodes
from teether.constraints import check_model_and_resolve, model_to_calls
from teether.evm.exceptions import IntractablePath
from teether.evm.results import CombinedSymbolicResult
from teether.util.z3_extra_util import concrete, get_vars_non_recursive, to_bytes, simplify_non_const_hashes
import teether.ponziSchemes as ponziSchemes
from teether.util.utils import bytes_to_int

import time
import timeout_decorator
import sha3

CALLER = 0
SYMVAR = 1
DSA    = 2
MAP    = 3

HASHMAP = dict()

def debug_hash_map():
    global HASHMAP
    sn = [sha3.keccak_256(item.to_bytes(length=32, byteorder='big')).hexdigest() for item in range(64)]
    for i, s in enumerate(sn):
        HASHMAP[s] = i
        
    

class InfeasibleExploit(Exception):
    pass


class FCSigError(Exception):
    pass


class ExploitContext(object):
    def __init__(self, target_addr, shellcode_addr, target_amount, amount_check, initial_balance, initial_storage,
                 controlled_addrs=set()):
        self.target_addr = target_addr
        self.shellcode_addr = shellcode_addr
        self.target_amount = target_amount
        self.amount_check = amount_check
        self.initial_balance = initial_balance
        self.initial_storage = initial_storage

        # assume we control the target address
        self.controlled_addrs = controlled_addrs | {target_addr}


def exploit_constraints_call(r, ctx):
    addr = r.state.stack[-2]
    if not concrete(addr):
        addr = z3.simplify(addr)

    amount = r.state.stack[-3]
    if not concrete(amount):
        amount = z3.simplify(amount)

    extra_constraints = []

    if not concrete(addr):
        extra_constraints.append(z3.Extract(159, 0, addr) == ctx.target_addr)
    else:
        if addr != ctx.target_addr:
            raise InfeasibleExploit

    if not concrete(amount):
        if ctx.amount_check == '+':
            extra_constraints.append(z3.UGE(amount, ctx.target_amount))
        elif ctx.amount_check == '-':
            extra_constraints.append(z3.UGT(amount, 0))
            extra_constraints.append(z3.ULE(amount, ctx.target_amount))
        else:
            extra_constraints.append(amount == ctx.target_amount)
        final_balance = r.state.balance
        extra_constraints.append(z3.ULE(amount, final_balance))

    # ensure we're not spending more for this exploit than we gain
    total_spent = None
    for res in r.results:
        callvalue = z3.BitVec('CALLVALUE_%d' % res.xid, 256)
        extra_constraints.append(z3.ULE(callvalue, 10 * (10 ** 18)))  # keep it semi-reasonable: at most 10 Eth per call
        if total_spent is None:
            total_spent = callvalue
        else:
            total_spent += callvalue

    extra_constraints.append(z3.ULT(total_spent, amount))

    # also, ensure the contract does not require a unreasonable start-balance (>100 Eth)
    if not ctx.initial_balance:
        start_balance = z3.BitVec('BALANCE_%d' % r.results[0].xid, 256)
        extra_constraints.append(z3.ULE(start_balance, 100 * (10 ** 18)))

    return extra_constraints


def exploit_constraints_callcode(r, ctx):
    addr = z3.simplify(r.state.stack[-2])

    extra_constraints = []

    if not concrete(addr):
        extra_constraints.append(z3.Extract(159, 0, addr) == ctx.shellcode_addr)
    else:
        if addr != ctx.shellcode_addr:
            raise InfeasibleExploit

    return extra_constraints


def exploit_constraints_delegatecall(r, ctx):
    addr = z3.simplify(r.state.stack[-2])

    extra_constraints = []

    if not concrete(addr):
        extra_constraints.append(z3.Extract(159, 0, addr) == ctx.shellcode_addr)
    else:
        if addr != ctx.shellcode_addr:
            raise InfeasibleExploit

    return extra_constraints


def exploit_constraints_selfdestruct(r, ctx):
    addr = z3.simplify(r.state.stack[-1])

    extra_constraints = []

    if not concrete(addr):
        extra_constraints.append(z3.Extract(159, 0, addr) == ctx.target_addr)
    else:
        if addr != ctx.target_addr:
            raise InfeasibleExploit

    return extra_constraints

def exploit_constraints_invest(r, ctx, payable=False):
    tmp = r.state.stack[-1]
    logging.info(f'# payable = {payable}#Try to solve: storage@')
    # slot = r.state.stack[-1] if concrete(tmp) else z3.simplify(tmp)
    addr = r.state.stack[-2]

    extra_constraints = []
    if not concrete(addr):
        extra_constraints.append(z3.simplify(z3.Extract(159, 0, addr)) == ctx.target_addr)
    else:
        if addr != ctx.target_addr:
            raise InfeasibleExploit

    for res in r.results:
        callvalue = z3.BitVec('CALLVALUE_%d' % res.xid, 256)
        if payable:
            extra_constraints.append(z3.UGT(callvalue, 0)) 
        else:
            extra_constraints.append(callvalue == 0) 


    # also, ensure the contract does not require a unreasonable start-balance (>100 Eth)
    # if not ctx.initial_balance:
    #     start_balance = z3.BitVec('BALANCE_%d' % r.results[0].xid, 256)
    #     extra_constraints.append(z3.ULE(start_balance, 100 * (10 ** 18)))

    return extra_constraints

EXPLOIT_CONSTRAINTS = {
    # 'CALL': exploit_constraints_call,
    # 'CALLCODE': exploit_constraints_callcode,
    # 'DELEGATECALL': exploit_constraints_callcode,
    'SSTORE': exploit_constraints_invest
}


def get_exploit_constraints(r, ctx):
    target_op = r.results[-1].target_op
    if target_op in EXPLOIT_CONSTRAINTS:
        return EXPLOIT_CONSTRAINTS[target_op](r, ctx)
    else:
        return []

def control_address_constraints(sym_addr, controlled_addrs):
    sub_exprs = [sym_addr == controlled_addr for controlled_addr in controlled_addrs]
    expr = sub_exprs[0]
    for sub_expr in sub_exprs[1:]:
        expr = z3.Or(expr, sub_expr)
    return expr

def attempt_exploit(results, ctx):
    c = CombinedSymbolicResult()
    for r in results[::-1]:
        c.prepend(r)
    c.combine(ctx.initial_storage, ctx.initial_balance)
    c.simplify()
    extra_constraints = get_exploit_constraints(c, ctx)

    for res in c.results:
        origin = z3.BitVec('ORIGIN_%d' % res.xid, 256)
        caller = z3.BitVec('CALLER_%d' % res.xid, 256)
        # ensure we control the origin
        extra_constraints.append(control_address_constraints(origin, ctx.controlled_addrs))
        # and ensure the caller is either the origin or the shellcode address
        extra_constraints.append(control_address_constraints(caller, {origin, ctx.shellcode_addr}))

    try:
        model = check_model_and_resolve(c.constraints + extra_constraints, c.sha_constraints)

        # enforce we control all ORIGIN-addresses
        if any(model[v].as_long() not in ctx.controlled_addrs for v in model if v.name().startswith('ORIGIN')):
            raise InfeasibleExploit

        return True# model_to_calls(model, c.idx_dict), c, model
    except IntractablePath:
        raise InfeasibleExploit

def attempt_exploit1(results, ctx, payable=False):
    c = CombinedSymbolicResult()
    for r in results[::-1]:
        c.prepend(r)
    c.combine(ctx.initial_storage, ctx.initial_balance)
    c.simplify()
    extra_constraints = exploit_constraints_invest(c, ctx, payable=payable)

    for res in c.results:
        origin = z3.BitVec('ORIGIN_%d' % res.xid, 256)
        # caller = z3.BitVec('CALLER_%d' % res.xid, 256)
        # ensure we control the origin
        extra_constraints.append(control_address_constraints(origin, ctx.controlled_addrs))
    try:
        model = check_model_and_resolve(c.constraints + extra_constraints, c.sha_constraints)
        # enforce we control all ORIGIN-addresses
        if any(model[v].as_long() not in ctx.controlled_addrs for v in model if v.name().startswith('ORIGIN')):
            raise InfeasibleExploit
        return True #model_to_calls(model, c.idx_dict), c, model
    except IntractablePath:
        raise InfeasibleExploit


def simplify_str(value):
    #print ("type: " + str(type(value)))
    if type(value) == int:
        return str(value)
    elif type(value) == str:
        return str(value).replace('\n', ' ')
    elif type(value) == bool:
        return str(value)
    elif type(value) == list:
        return ",".join(simplify_str(f) for f in value)
    else:
        return " ".join(str(simplify(value)).split())

def feat_body(expr):
    if expr.num_args() == 0: # a symbolic
        return None
    elif expr.decl().name() == 'bvand':
        children = expr.children()
        body = children[1] if simplify_str(children[0]).strip() == str(((2 << 160 - 1) - 1)).strip('L')  else children[0]
        return body
    else:
        return None

def is_read_from(one, usrDB):
    for item in usrDB:
        ins_addr, index, _,_  = item
        if one == index:
            return item
    return None
    
    if not self.symbolic_reads and not other.symbolic_writes:
        # no side has a non-hash-based symbolic access
        # => only concrete accesses can intersect
        # (or hash-based accesses, which we will check later)
        if self.concrete_reads & other.concrete_writes:
            return True
    else:
        # at least one side has a non-hash-based symbolic access
        # => if there is at least one concrete or symbolic access
        # on the other side, the two could be equal
        # (otherwise we have to look at hash-based accesses, see below)
        if ((self.symbolic_reads or self.concrete_reads or self.symbolic_hash_reads) and
                (other.symbolic_writes or other.concrete_writes or other.symbolic_hash_writes)):
            return True

    if self.symbolic_hash_reads and other.symbolic_hash_writes:
        for a, b in itertools.product(self.symbolic_hash_reads, other.symbolic_hash_writes):
            if not ast_eq(a, b):
                continue
            hash_a = list(self._vars[a] & set(self.result.sha_constraints.keys()))
            hash_b = list(other._vars[b] & set(other.result.sha_constraints.keys()))
            if len(hash_a) != 1 or len(hash_b) != 1:
                # multiple hashes on either side
                # => assume they could be equal
                return True
            # only one hash on either side
            # => check whether these two can actually be equal
            d_a = self.result.sha_constraints[hash_a[0]]
            d_b = other.result.sha_constraints[hash_b[0]]
            if isinstance(d_a, SymRead) or isinstance(d_b, SymRead):
                return True
            if d_a.size() == d_b.size():
                return True

    # at this point, we have checked every possible combination
    # => no luck this time
    return False



def feat_key_base(laser, expr):
   #( storage_0 + keccak256[65535 & UDiv(storage_0, 65536), 1])
    str_key_adr = str(expr)[8:]
    sym_key_adr = laser.varlist[str_key_adr]
    adc = sym_key_adr.children()
    if adc:
        sym_keccakp, struct_idx  = adc if 'keccak256[' in str(adc[0]) else adc[::-1]
        key, base = laser.keccaks[str(sym_keccakp)]
    else:
        key, base = laser.keccaks[str(sym_key_adr)]
    return key, base

def is_caller(expr):
    # print(expr)
    if re.search("^Extract\(159, 0, CALLER_\d+\)$", str(expr)) or \
        re.search("^Extract\(255, 96, 79228162514264337593543950336\*CALLER_\d+\)$", str(expr)) or \
        re.search("^Extract\(255, 96, CALLER_\d+\*79228162514264337593543950336\)$", str(expr)) :
        return True
    return False

def is_origin(expr):
    # print(expr)
    if re.search("^Extract\(159, 0, ORIGIN_\d+\)$", str(expr)) or \
        re.search("^Extract\(255, 96, 79228162514264337593543950336\*ORIGIN_\d+\)$", str(expr)) or \
        re.search("^Extract\(255, 96, ORIGIN_\d+\*79228162514264337593543950336\)$", str(expr)) :
        return True
    return False

def get_concrete(address):
    if isinstance(address, z3.BitVecNumRef):
        return True, address.as_long()
    elif isinstance(address, numbers.Number):
        return True, int(address)
    else:
        return False, address

def get_storage_expr_base1(r, expr):
    try:
    # if is_caller(expr):
    #     return CALLER, -1     
        if expr.decl().name() == 'extract':
            # print(expr.children(), expr)
            p_h, p_l = expr.decl().params()
            expr =expr.children()[0]
            if p_h - p_l == 159:
                # type: address
                if p_h == 159:
                    expr = expr
                else:
                    tmp = expr.children()
                    print("TMP:", tmp)
                    expr = tmp[0] if tmp[0].decl().name() == 'select' else tmp[1]
            else:
                expr = expr.children()[0]
                if expr.decl().name() == 'bvmul':
                    tmp = expr.children()
                    expr = tmp[0] if tmp[0].decl().name() == 'select' else tmp[1]
    

        # select()
        address = expr.children()[1]
        # print('func: ',address, type(address))
        res, address = get_concrete(address)
        if res:
            # print("is concrete:", address)
            if address <= 1024:
                return SYMVAR, address, None
            else:
                print(hex(address)[2:])
                return DSA, hash2idx(hex(address)[2:]), 0
        
        elif address in r.sha_constraints:
            #sha3
            identity = r.sha_constraints[address]
            if identity.decl().name() == 'concat':
                # print(base.children())
                key, base = identity.children()
                # print('key=', key)
                return MAP, base, key
        else:
            var_adds = address.children()
            i = 0
            while i < len(var_adds):
                one_var = var_adds[i]
                if one_var.decl().name() == 'bvadd':
                    var_adds = var_adds[:i] + one_var.children() + var_adds[i+1:]
                else:
                    i += 1
            first_var = var_adds[0]
            _, base = get_concrete(first_var)
            key = 0
            for item in var_adds[1:]:
                key = key+item
            return DSA, hash2idx(hex(int(base))[2:]), key
    except Exception as e:
        return None, None, None
        
def get_storage_expr_base(r, expr):
    # if "storage_" not in str(expr):
    #     return -1
    # get_vars_non_recursive 取出会影响其值的部分
    try:
        if is_caller(expr):
            return CALLER, -1
        # if re.search("^Extract\(159, 0, CALLER_\d*\)$", str(expr)):
        #     return CALLER, -1
        # quick scan => symbolic variable
        tmp = re.search("^Extract\(159, 0, STORAGE_\w*\[(\d*)\]\)$", str(expr))
        if tmp:
            if re.search(r"([0-9]{70,80})", tmp.group(1)):
                return SYMVAR, hash2idx(hex(int(tmp.group(1)))[2:]) 
            else:
                return SYMVAR, int(tmp.group(1))
        
        if expr.decl().name() == 'extract':
            expr = expr.children()[0]


        tmp = re.search("STORAGE_\w+\[(SHA3_\w+)\]", str(expr))
        if tmp:
            var_set = get_vars_non_recursive(expr)
            for var in var_set:
                if 'SHA3_' not in str(var):
                    continue
                base = r.sha_constraints[var]
                # print("base == ", base)
                if base.decl().kind() == 1056:# Concat
                    # print(base.children())
                    key = int(str(base.children()[-1]))
                    # print('key=', key)
                    return MAP, key
        else:
            # DSA
            # print('[+] expr=', expr, 'expr.children() = ',expr.children())
            address = expr.children()[1]
            # print("[+] DSA::::???:::", address, type(address), z3.simplify(address))
            address = z3.simplify(address)
            if len(address.children()) == 0:
                tmp = re.search(r"([0-9]{70,80})", str(address))
                if isinstance(address, z3.BitVecNumRef):
                    address = address.as_long()
                elif concrete(address):
                    address = int(address)

                if tmp:
                    return DSA, hash2idx(hex(int(tmp.group().strip()))[2:]) 
                return SYMVAR, address

            # children.length > 0
            # print('================\n', address, '============================')
            sym_vars = address.children()
            # print(sym_vars)
    
            if 'Store' in str(sym_vars[1]) or 'STORAGE' in str(sym_vars[1]) or "CALLDATA" in str(sym_vars[1]):
                base = re.search(r"([0-9]{70,80})", str(sym_vars[0])).group().strip()
            else:
                base = re.search(r"([0-9]{70,80})", str(sym_vars[1])).group().strip()
            # print('base::', base)
            
            return DSA, hash2idx(hex(int(base))[2:]) 

        return MAP, -1
    except Exception as e:
        # print(e)
        return -1, -1
    return -1, -1
    # if extract_base()

    # Extract(159, 0, {hash(slot) + offset)
        # Mapping
        
def hash2idx(_hash):
    # print(HASHMAP)
    for key in HASHMAP.keys():
        if 0 <= int(_hash, 16) - int(key, 16) <= 4096:
            # print("Found --->", HASHMAP[key])
            return HASHMAP[key]
    return -1

def get_sidx(r, adr):
    # 62514009886607029107290561805838585334079798074568712924583230797734656856475 + STORAGE_1[4] + 1 - 1
    try:        
        # tmp = re.search(r"([0-9]{70,80})", str(adr))
        # if isinstance(adr, z3.BitVecNumRef):
        #     adr = adr.as_long()
        # elif concrete(adr):
        #     adr = int(adr)

        # if tmp:
        #     return hash2idx(hex(int(tmp.group().strip()))[2:]) 
        # return adr

        # if len(adr.children()) == 0:

        # SYMVAR
        tmp = re.search(r"([0-9]{70,80})", str(adr))
        if isinstance(adr, z3.BitVecNumRef):
            if tmp:
                return hash2idx(hex(int(tmp.group().strip()))[2:]) 
            return adr.as_long()
        elif concrete(adr):
            if tmp:
                return hash2idx(hex(int(tmp.group().strip()))[2:]) 
            return adr
        # print(r.sha_constraints)
        # print(r.sha_constraints[z3.z3util.get_vars(adr)[0]])
        adr_str = str(adr).replace('\n', ' ').strip()
        # print("address = ", adr, adr_str.count("SHA3_"))
        # mapping
        if adr_str.count("SHA3_") == 1:
            # Concat(0, Extract(159, 0, CALLER_1), 0)
            base = r.sha_constraints[z3.z3util.get_vars(adr)[0]] 
            # print("base == ", base)
            if base.decl().kind() == 1056:# Concat
                # print(base.children())
                key = int(str(base.children()[-1]))
                # print('key=', key)
                return key
        # DSA
        else:
            # print('[-] feat_base::', adr)
            base_adr = re.search(r"([0-9]{70,80})", adr_str).group().strip()
            # print('inline---', base_adr)
            return hash2idx(hex(int(base_adr))[2:]) 
    except:
        return -1

def prase_bonus(r, expr):
    try:
        # print('bonus### ',z3.z3util.get_vars(expr))
        for child in expr.children():
            if child.decl().name() == 'select':
                kind, base = get_storage_expr_base(r, children)
            else:
                pass
            
            s = z3.Solver()
            s.add(expr == 1e20)
            if s.check == z3.sat:
                return s.model().eval(var).as_long() / 1e20

    except:
        pass
    return None


def prase_ast(expr):
    children = list()
    if expr.children() == []:
        return expr
    for child in expr.children():
        if child.decl().name() == 'select':
            children.append(z3.BitVecVal(1e20, child.size()))
        else:
            children.append(child)

    op = expr.decl().name()
    print('[+] expr=', expr, '\n[+]childrens = ', children)
    if op == 'bvadd':
        return prase_ast(children[0]) + prase_ast(children[1])

    if op == 'bvsub':
        return prase_ast(children[0]) - prase_ast(children[1])

    if op == 'bvmul':
        return prase_ast(children[0]) * prase_ast(children[1])
    
    elif op == 'bvudiv':
        return z3.UDiv(prase_ast(children[0]), prase_ast(children[1])) 
    
    elif op == 'bvsdiv':
        return prase_ast(children[0]) / prase_ast(children[1])

    elif op == 'bvand':
        return prase_ast(children[0]) & prase_ast(children[1])

    elif op == 'bvor':
        return prase_ast(children[0]) | prase_ast(children[1])



def get_func_sig(p, path):
    '''
    DUP1      
    PUSH4     0x27e235e3# func_sig
    EQ        
    PUSH2     addr
    JUMPI    
    '''
    func_sig, jump_addr = None, None
    dispatcher_pattern = ['DUP1', 'PUSH4', 'EQ', 'PUSH2', 'JUMPI']
    pattern_size = len(dispatcher_pattern)
    # print("Path: %s", '->'.join('%x' % p for p in path))
    for i, node in enumerate(path[:-1]):
        bb = p.cfg._bb_at[node]
        next_node = path[i+1]
        if len(bb.ins) < pattern_size:
            continue
        todo_match = [(_i.name, _i.arg) for _i in bb.ins][-1*pattern_size:]
        idx = 0
        while idx < pattern_size:
            name, arg = todo_match[idx] 
            if name != dispatcher_pattern[idx]:
                break
            if name == 'PUSH4':
                func_sig = arg.hex()
            if name == 'PUSH2':
                jump_addr = arg.hex()
            idx += 1
        if idx == pattern_size and int(jump_addr, 16) == next_node:
            return func_sig

    return 'fallout'


def convert_concrete(v):
    if isinstance(v, numbers.Number):
        return v

    elif isinstance(v, z3.BitVecNumRef):
        return v.as_long()
    return v


def constraint_require_pay(i_r, func_sig):
    if func_sig == 'fallout':
        return True

    if not any(["CALLVALUE" in str(item) for item in i_r.constraints]):
        return False

    # if one contraint require callvalue > 0
    # => find a path to invest (sstore msg.sender)
    # e.g.  If(UGT(CALLVALUE_9, 1000000000000000000), 1, 0) == 1
    for _cons in i_r.constraints:
        print(_cons)
        # quick mode
        try:
            svars = z3.z3util.get_vars(_cons)
            if not(len(svars) == 1 and str(svars[0]).startswith("CALLVALUE_")):
                continue
            var_callvalue = svars[0]
            s = z3.SolverFor("QF_ABV")
            s.add(_cons)
            s.push()
            s.add(var_callvalue == 0)
            if s.check() == z3.unsat:
                # print("fitst solver === ", s)
                s.pop()
                s.add(z3.UGT(var_callvalue, 0))
                # print("second solver ===", s)
                if s.check() == z3.sat:
                    return True
        except:
            continue
    
    # the path is reachable ,iff the callvalue is larger than zero
    # try:
    #     # the path is unreachable if callvalue equal to zero
    #     if attempt_exploit1([i_r], ctx, payable=False):
    #         return False
    #         # print("===================== payable False Solved ===================")
        
    # except InfeasibleExploit as e:
    #     # print("===================== payable False unSolved ===================")
    #     try:
    #         # the path is reachable iff callvalue larger than zero
    #         _ = attempt_exploit1([i_r], ctx, payable=True)
    #         # print("===================== payable True Solved ===================")
    #         return True
    #         # return results
    #     except InfeasibleExploit as e:
    #         # print("===================== payable True unSolved ===================")
    #         return False
    return False

# @timeout_decorator.timeout(10*60, timeout_exception=StopIteration, use_signals=False)
def combined_exploit(p, target_addr, shellcode_addr, target_amount, amount_check='+', initial_storage=dict(),
                     initial_balance=None,
                     max_calls=3, controlled_addrs=set(), flags=None, looplimit=3):

    global HASHMAP
    sn = [sha3.keccak_256(item.to_bytes(length=32, byteorder='big')).hexdigest() for item in range(64)]
    for i, s in enumerate(sn):
        HASHMAP[s] = i

    results = list()
    # flags = flags or set(opcodes.CRITICAL)
    ctx = ExploitContext(target_addr, shellcode_addr, target_amount, amount_check, initial_balance, initial_storage,
                         controlled_addrs)
    # ========================================================================
    calls = p.cfg.filter_ins('CALL') 
    print(len(calls))
    if not calls:
        return False
    for call_i, call_p, call_r in p.get_constraints(calls): # call
        if (not call_i) or (not call_p) or (not call_r):
            continue
        print("="*40)
        _gas, _receipt, _value, argO, argL, retO, retL = call_r.state.stack[-7:][::-1]
        # print('[+] xcall-> ',hex(bytes_to_int(call_r.state.memory.read(argO, 32)[:4] ))) # functing sig/calldata
        if not concrete(_receipt): 
            # print('[+] receipt = ', z3.simplify( _receipt))
            calldata = call_r.state.memory.read(argO, 32) # functing sig/calldata
            print()
            with open('/home/toor/SADPonzi/dataset/cross_cases/oldeth.bin') as infile:
                inbuffer = infile.read().rstrip()
            xcode = bytes.fromhex(inbuffer)
            xp = Project(xcode)
            for x_i, x_p, x_r in xp.get_constraints(xp.cfg.filter_ins('RETURN')):
                try:
                    # print('[+] calldata =', calldata)
                    xfunc_sig = ''.join([hex(d)[2:] for d in calldata[:4]])
                    print("[+] xfinc_sig=", xfunc_sig)
                except:
                    pass
                if xp.get_func_sig(x_p) != xfunc_sig:#hex(bytes_to_int(calldata[:4]))[2:]:
                    continue
                # print(x_i)
                xretO, xretL = x_r.state.stack[-2:][::-1]
                xretMem = x_r.state.memory.read(xretO, xretL)
                # exit(0)
                p.xcall.append((call_i.addr, xretMem))
                break
                # except:
                    # continue
        print('[+] receipt = ', z3.simplify( _receipt).children()[1].children()[0].children()[1])
        # if EXT_xx:
        # replace with retVal
        # print('---\n', argO, '---\n', argL,'---\n',  retO,'---\n', retL)
        # print(hex(bytes_to_int(call_r.state.memory.read(argO, 32)[:4] ))) # functing sig/calldata
        # print(p.get_func_sig(call_p))
        
    return False
   